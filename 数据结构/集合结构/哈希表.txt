哈希表是基于数组实现的,插入-查询删除非常快
哈希表的查询速度非常快,基本瞬间查找到想要的元素
哈希表就是关键字到地址的映射

哈希表对于数组的一些不足
哈希表中的数据是没有顺序的,所以不能以一种固定的方式来遍历元素
通常情况下,哈希表中的key是不允许重复的,不能放置相同的key,value可以重复  

哈希表的结构就是数组,可以对下标值进行变换,这种变化称为哈希函数,通过哈希函数获得HashCode
哈希函数让某个key的信息和索引值对应起来

幂的连乘可以把保证数据唯一性
如:7654 = 7*10^3+6*10^2+5*10^1+4*10^0

哈希化:将大数字转化为数组范围下标的过程
哈希函数:通常将单词转为大数字,大数字进行哈希化的代码放在一个函数中,这个函数称为哈希函数

什么是冲突?
在哈希化过程中,转成的下标值可能会是相同的,这就是冲突.冲突不可避免,只能解决冲突
解决冲突的两种方案:
1.链地址法 2.开放地址法

链地址法:
链地址法解决冲突的方法是将数组或链表存储到,数组当中,而不是存放单独的数据
即,数组的每个数组单元存储着一个链表或数组,当对元素进行哈希化时,若下标值相同,就将其存入此数组单元的链表或数组中
查询时,根据对应的下标值,取出对应的链表和数组,从而遍历链表,获得数据

开放地址法:
通过寻找空白单元格来添加冲突的数据项
三种寻找方案
1.线性查找 
    线性查找的查找步长为1,插入时若位置被占,则位置+1,继续寻找空白格.查询时,若查询到空位置,则说明没查找到此函数
    删除元素时不能不能设置为空,应当设一个特殊值(如-1)
    聚集会影响哈希表的性能
2.二次探索
    主要优化探测的步长,X+1^2,x+2^2...依次类推
3.再哈希法
    根据不同的关键字,来探测序列
    步长在整个探测过程中是不变的,不过不同的关键字使用不同的步长
stepSize = constant - (key % constant)
其中constant是质数,且小于数组容量


设计一个好的哈希函数应该具备以下优点:
1.快速计算
    哈希表的优势在于效率,所以快速获得hashcode很重要
2.均匀分布
    哈希表中,无论是链地址法还是开放地址法,当多个元素映射到同一个位置时,都会影响效率
    所以优秀的哈希函数应该尽可能的将元素映射到不同位置,让元素在哈希表中均匀分布  
    采用质数,更有利于元素在数组上的均匀分布

哈希表的扩容思想
为什么需要扩容?
随着数据量的增多,每一个index对应的bucket会越来越长,造成效率的降低,在合适的情况,对数组进行扩容两倍

如何进行扩容? 
简单的将容量扩大两倍,所有的数据项都需要调整位置(重新调用哈希函数)

什么情况进行扩容?
当装载因子(loadFactor>0.75)时进行扩容
loadFactor = 已存放元素个数/容量



-----------------总结---------------------
哈希表是基于数组实现的,保存着 key-value 对,可以根据key快速查找到对应的value,key不允许重复


需要通过哈希函数,将key哈希化,获得对应数组的索引
哈希函数实现
    1.先将字符串转为较大的数字,质数*hashcode+str.charCodeAt(i) --公式-使用unicode编码
    2.再将hashcode压缩到数组范围内, 对hashcode取模获得索引index,即 index = hashcode % 哈希表容量


哈希化过程会造成,哈希表地址冲突,冲突不可避免,只能想办法解决
1.链地址法 2.开放地址法
